/* 
 * File:   TokenChecker.cpp
 * Author: Eduar Castrillo (eduarc)
 * 
 * Created on April 25, 2013, 6:13 PM
 */

#include "TokenChecker.h"
#include "CheckerReply.h"

#include <cstdlib>
#include <cstdio>
#include <cstring>

using namespace std;

#define MAX_TOKENS 524288

  // Used to store the tokens generated by the original output
char *src_tokens[MAX_TOKENS];

/*
 * dst_path contains the file generated for the problem setter (original)
 * src_path contains the file generated for the user program
 * 
 * content in file src will be matched against content in dst.
 * 
 * Token check consist in to take each token from the file and compare then.
 * If a mismatch is found WRONG_ANSWER is returned, else ACCEPTED.
 * If we got in a problem then INTERNAL_ERROR is returned
 */
int TokenChecker::check(const char *src_path, const char* dst_path, const char *separator) {
  
  FILE *src = fopen(src_path, "r");
  if (src == NULL) {
    // LOG here!
    return CheckerReply::INTERNAL_ERROR;
  }
  
  FILE *dst = fopen(dst_path, "r");
  if (dst == NULL) {
    // LOG here!
    return CheckerReply::INTERNAL_ERROR;
  }
  
    // Size is in bytes
  fseek(src, 0, SEEK_END);
  int src_size = ftell(src);
  fseek(dst, 0, SEEK_END);
  int dst_size = ftell(dst);
  
  rewind(src);
  rewind(dst);
  
  if (strcmp(separator, "\0") == 0) {
    if (src_size != dst_size) {
      fclose(src); fclose(dst);
      return CheckerReply::WRONG_ANSWER;
    }
  }
  
  int n_tokens = 0;
  char *src_buff = (char *)malloc(sizeof(char) * src_size + 1);
  char *dst_buff = (char *)malloc(sizeof(char) * dst_size + 1);
  
  memset(src_buff, '\0', src_size);
  memset(dst_buff, '\0', dst_size);
  
  if (!src_buff || !dst_buff) {
      // LOG here!
    free(src_buff); free(dst_buff);
    fclose(src);    fclose(dst);
    return CheckerReply::INTERNAL_ERROR;
  }
  
  int bytes = fread(src_buff, 1, src_size, src);
  if (bytes != src_size) {
      // LOG here!
    free(src_buff); free(dst_buff);
    fclose(src);    fclose(dst);
    return CheckerReply::INTERNAL_ERROR;
  }
  
  bytes = fread(dst_buff, 1, dst_size, dst);
  if (bytes != dst_size) {
    // LOG here!
    free(src_buff); free(dst_buff);
    fclose(src);    fclose(dst);
    return CheckerReply::INTERNAL_ERROR;
  }
  
  char *ptr = strtok(src_buff, separator);
  
  while (ptr && n_tokens < MAX_TOKENS) {
    src_tokens[n_tokens++] = ptr;
    ptr = strtok(0, separator);
  }
  
    // tokens limit reached
  if (n_tokens == MAX_TOKENS && ptr) {
    // LOG here!
    free(src_buff); free(dst_buff);
    fclose(src);    fclose(dst);
    return CheckerReply::INTERNAL_ERROR;
  }
  
  ptr = strtok(dst_buff, separator);
  
    // answer is nothing
  if (n_tokens == 0 && ptr) {
    free(src_buff); free(dst_buff);
    fclose(src);    fclose(dst);
    return CheckerReply::WRONG_ANSWER;
  }
  
  for (int i = 0; i < n_tokens; ++i) {
      // Mismatch found...
    if (!ptr || strcmp(src_tokens[i], ptr)) {
      free(src_buff); free(dst_buff);
      fclose(src);    fclose(dst);
      return CheckerReply::WRONG_ANSWER;
    }
    ptr = strtok(0, separator);
  }
  free(src_buff); free(dst_buff);
  fclose(src);    fclose(dst);
  return CheckerReply::ACCEPTED;
}